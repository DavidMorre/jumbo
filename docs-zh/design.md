# Jumbo 设计与实现
本文讲述的是 jumbo 0.4.4 版本

## Jumbo 需求分析
首先从功能角度出发。作为一个包管理工具，必须具备以下几个基本功能：
* 列出所有可以安装的程序
* 安装指定的程序及其依赖
* 卸载指定的程序
* 将制定的程序升级到更新版本
* 列出所有已安装的程序
* 可以找到不再被依赖的程序并将其卸载

另外还有一些非功能需求：
* 使用者可以指定 jumbo 安装的程序的路径，很有可能不是系统路径
* 条件允许的情况下尽可能复用系统中自带的库（如 glibc 不会考虑自己安装一套）
* Jumbo 自身的安装过程必须又简单，又快
* Jumbo 自身的外部依赖必须尽可能少，最好公司的测试机上什么都不需要安装就可以直接支持
* Jumbo 的操作方式应尽可能简单
* Jumbo 的输出内容必须格式简单、友好、一目了然
* 程序的安装目录，需要符合 [Filesystem Hierarchy Standard](http://refspecs.linuxfoundation.org/FHS_2.3/fhs-2.3.html)
* 程序描述文件（简称 jam 文件，即 Jumbo Application Metafile 的简称）格式简单，新增一个程序成本较低

先来考虑一下业界的现成方案。首先想到的是公司用的 rhel 上自带的 yum。yum 要求使用者必须有 root 权限，但是大部分用户都没有 root 权限。同理其他的二进制发布的包管理系统如 aptitude 等就不适用了。因此只剩下可通过源码发布的。考虑过 gentoo prefix，但是那样相当于直接重装整套系统，只是复用了内核，有点过于复杂。就算只应用它的 portage 系统，gentoo 的 ebuild 描述文件相对较复杂，因此不考虑。Mac 上的 homebrew 系统也调研过，但是由于是专门为 mac 设计的，并且依赖 ruby（公司机器上默认不安装 ruby），因此不予考虑。Archlinux 的 pacman 看似不错，也因为需要编译安装而被暂时否定（最开始的设计目标是 0 安装）。因此最终我们决定借鉴 pacman 的思路，自己开发一套简单版本的包管理系统。

针对上述的需求，就能给出 jumbo 最初的几个 design decision。

首先，程序的安装部分是 jumbo 最核心的功能。我们参考过业界许多系统的安装方式，面临了两个选择：是二进制发布，还是源码发布？业界最常用的安装方式是统一编译一次，然后安装的时候直接安装二进制文件。这样的做法好处是很简单，安装很快，但是坏处是和路径相关的信息会在编译的时候编译到二进制文件中，会造成二进制文件不可转换路径。在我们的需求中，能够让用户安装到自己的目录中是最重要的一点，因此二进制发布的方式就被我们否决了，决定采用源码发布的方式来发布软件包。

决定采用源码发布了之后，又有几个事情需要我们做决定。发布包中应该包含什么内容、软件列表发布格式是怎么样的，等等。关于这一点的想法，主要还是考虑借鉴业界的一些做法，主要参照目标有 ebuild 和 PKGBUILD。由于 ebuild 文件格式较复杂，我们决定继承 Archlinux 的 PKGBUILD 的规范并做少量修改。这样做有以下优势：
* 学习成本低。相较于 Debian/Redhat 的包描述，Archlinux 的包描述非常简单，只要会手工编译就能写，几乎无学习成本。
* 资源非常丰富。Archlinux 官方以及 AUR 提供了大量现成的 PKGBUILD，稍加修改即可使用。

最后，为了将外部依赖降至最低，保证在大部分环境下都能正常运行，并且安装过程足够快，我们选择使用 shell 脚本的方式来实现 jumbo 的功能。

## Jumbo 内部结构
Jumbo 内部大致可以拆分成几个部分
* 软件仓库管理
* 依赖处理
* 程序安装部分
* 程序交互部分
* 基础性辅助工具

## 软件仓库管理
Jumbo软件仓库管理一共管理几个文件：
* 本地缓存 jam 文件目录 $JUMBO_ROOT/var/jumbo/jam/
* 本地缓存所有软件列表 $JUMBO_ROOT/var/jumbo/list
* 本机已经安装的软件列表 $JUMBO_ROOT/var/jumbo/installed_list

Jumbo 执行时，会根据本地缓存的时间来判断。如果需要，则会向远程仓库请求 http://jumbo.ws/list.tar.gz 文件。这个 tar 文件是将 jumbo 提供的所有 jam 文件打包而成。将这个文件下载下来后，jumbo 会将所有 jam 文件扫描一遍，获取其中的基本信息，按 jamlist 格式输出至缓存的软件列表文件 $JUMBO_ROOT/var/jumbo/list 中。

Jamlist 格式的文件中，每一行代表一个软件包，每行有五个字段，用 tab 分隔。这五个字段，按顺序分别为：
* 包名 pkgname
* 当前版本 pkgver 和 pkgrel
* jam 文件所在路径
* 人类可读的描述
* 软件包依赖

软件仓库部分对外还提供了封装性接口，其他模块中无需了解 jamlist 格式的细节，只要使用 jamlist 提供的封装接口就行了。

## 程序安装部分
最符合 jumbo 需求的安装方式，就是传统的 ./configure && make && make install 的方式，但是每个程序的安装过程又有些细微的区别。因此，为所有程序提供一个统一的安装脚本不可行，只能是针对不同的软件提供不同的安装脚本。于是就有了 jam 文件。

Jam 文件是一个 shell 语法编写的文件，关于 jam 文件的说明，可以参考 [jam 文件说明](http://jumbo.ws/jam.html)。软件安装部分，最主要关心的是 jam 文件中的 jumbo_install 函数。

安装后，用户可能需要卸载软件。如何实现软件的卸载？如果直接安装到目标路径，那所有文件都混在一起了，jumbo 也无法区分哪些文件是哪个软件提供的。为了区别每个包中含有哪些文件，一共有几种方案。第一种是所有软件都安装到各自的目录，然后在用户的 PATH 环境变量中将自己的 bin 目录加上。这样的好处是简单，但是坏处是 PATH 环境变量会变得很杂乱导致性能下降，而且有写软件可能也没法实现（比如 python 的库）。第二种方法是把所有软件安装到各自的目录，然后在一个统一的地方加上软链。这样的做法也挺简单，而且规避了上面 PATH 过长的问题，不过因为软链太多，较难管理，因此也决定不采用。第三种方案是直接安装到目标路径，前后分别对整个目录 find 一次，找出 diff。这种方法有一个最明显的问题，那就是万一用户在安装过程中操作这个目录，将导致最终结果不对。第四种方法是安装的时候先安装到一个临时安装目录，对里面的文件进行统计，最后才移到目标路径下。这种做法好处是精确，坏处是安装脚本编写的时候需要注意这一点。参考也业界的包管理软件的做法，我们最终决定采取第四种方案。

程序的安装过程简单描述大概可以分为以下几步：
* 将程序所需的源文件下载到本地，并验证其 md5 签名
* 如需要，自动解压缩下载的源文件
* 设置 CFLAGS CPPFLAGS LDFLAGS PKG_CONFIG_PATH 等变量，好让编译过程能正确找到其依赖库在 jumbo 中的路径
* 执行 jam 文件中的 jumbo_install 函数进行安装。jumbo_install 会将程序编译、安装到一个指定的临时安装路径中
* 在临时安装路径中，递归统计该包安装了哪些文件，并记录在 files 文件中（这么做的目的是为了提供删除软件的功能）
* 将临时安装路径中的文件移到实际安装路径
* 写安装日志

卸载软件时，只需要将 files 文件中列出的文件和目录删除即可。

如果是升级操作，则在安装完成后，会对当前的 files 文件和升级前的 files 文件做比对，将升级后缺少的文件删除。升级操作不能简单地先删除，后安装，是为了避免安装过程出现错误退出时，将导致原本可用的软件也被删除了的情况。

## 依赖处理
依赖处理部分比较简单，但是用 shell 实现的时候用了一些比较 tricky 的做法。

依赖处理部分，需要从给定的几个软件中，推算出所需要的安装顺序，要求被依赖的库必须先于依赖它的库进行安装。算法大致如下：

首先假设有几个软件包 A 到 G，他们之间的依赖关系如下：
* A 依赖 B D G
* B 依赖 C D E
* C 依赖 D E
* D 没有依赖
* E 依赖 F
* F 没有依赖
* G 没有依赖

假设使用者要安装 A C 时，需要算出 A C 的所有依赖。程序分为两大步，第一步先计算出所有依赖树，第二步对依赖树进行打平去重输出。第一步先迭代式地计算出所有依赖树，步骤如下：
* 第一次迭代，添加 A C，记录为 level0
* level0 为 A C，其所有依赖为 B D E G，记录为 level1
* level1 为 B D E G，其所有依赖为 C D E F，记录为 level2
* level2 为 C D E F，其所有依赖为 D E F，记录为 level3
* level3 为 D E F，其所有依赖为 F，记录为 level4
* level4 为 F，依赖为空，迭代退出

第二步则根据上面的结果，按 level 的倒序输出，并对已经输出过的进行去重。如按上面的例子，输出如下：
* level4 有 F，都没出现过，输出 F
* level3 有 D E F，扣除已经出现过的 F，输出 D E
* level2 有 C D E F，扣除已经出现过的 D E F，输出 C
* level1 有 B D E G，扣除已经出现过的 D E，输出 B G
* level0 有 A C，扣除已经出现过的 C，输出 A

得出最终安装顺序为 F D E C B G A

另外在安装后，jumbo 会将用户指定安装的软件单独保存起来。如果使用者后来将软件 A 删除，则 jumbo 会提示软件包 B G 已经不再被依赖，可以通过 jumbo clean来清理。而因为 C 是用户显式指定安装的，所以 C 和它的所有直接及间接依赖 D E F 都不会被列入待清理名单中。

## 程序交互部分
要想推广一个工具，最重要的就是要能解决问题。而仅此于此的，就是要好用。为了尽可能提高 jumbo 的易用性，我们在 jumbo 的交互上也下了不少心思。

首先是采用统一的调用方式 jumbo verb noun。用户在使用 jumbo 的时候，输入的命令比较自然，也比较好记。

另一方面是程序的输出。程序根据信息级别的不同，使用不同的颜色来标识，并且将关键信息（如包名）都使用颜色对其进行高亮，用户可以一眼就看到他需要关心的问题。输出的文本也尽量采用用户可以理解的语言来描述，而尽量不采用 jumbo 内部术语。

另外还有一点是在输出包列表和描述的时候，对于描述的折行也做了特殊处理，好让它折行的位置不在一个单词的中间位置，并且第二行也有相应的缩进。

上面的这些优化，都是为了给用户提供更好的使用体验，要让用户不仅觉得这是个好用的工具，也是个很容易用的工具。

## 基础性辅助工具
开发 jumbo 时，我将一些常用操作整理成一些辅助性工具，如文字高亮输出、输出错误信息并退出等。简化 jumbo 内部代码之余，写其他 shell 脚本时还可以直接复用当中的部分代码。

## Jumbo 中的一些 shell 技巧
Jumbo 的代码使用了一些 shell 的编写技巧：
* 使用 set -e 模式，一旦出错立即退出程序，这样可以避免一些程序错误形成雪球效应
* 功能封装在多个函数中，使用函数输入输出作为接口，可以将函数通过 pipe 组合起来实现复杂功能
* 全局变量只用于存放配置。函数不使用全局变量作为通信接口
* 全局变量使用大写变量名，局部变量使用小写变量名
* 集合求交集：cat a b | sort | uniq -d
* 集合求并集：cat a b | sort -u
* 集合求差集：cat a a b | sort | uniq -u

## Updates
现在的 jumbo 版本已经是 0.6.6 了。下面说说后面更新过的一些功能

### Hook
首先是支持了 pre/post install/update/remove 的 hook，支持有些软件安装完了之后需要做一些后续处理工作，或者输出额外信息，都可以使用这些 hook。

### 配置文件备份
其次是新加了 backups 功能，jam 文件中可以标记部分文件需要进行备份，就可以防止程序在升级的时候不小心覆盖了用户修改过的配置。具体逻辑如下：（假设更新前版本为 old，Jumbo 源中最新版本为 new，用户自己的版本为 user，配置文件为 conf）
* 如果 old == new == user，表明用户或者软件都没有修改过配置文件，不进行处理
* 如果 old == user, old != new，表明新版本更新过配置文件，并且用户没有修改过默认配置，直接用 new 进行替换
* 如果 old == new, old != user，表明软件没有更新过配置文件，但用户修改过默认配置，继续用 user 的配置
* 如果 old, new, user 两两均不相等，则代表程序更新过配置文件，并且用户也改过默认的配置项，沿用 user 的配置，并把 new 的配置写到 conf.new 里面并提示用户有新配置

另外在进行删除的时候，如果 old != user，则删除之前会将 conf 备份为 conf.bak，进行备份。

### 自动升级
虽然 jumbo 理念比较不太鼓励自动升级，但是如果使用太老版本的 jumbo 还是有可能和新的包不兼容导致安装的包不可用（我们接到过很多类似的 issue report 都是可以通过升级 jumbo 解决的，因此还是决定加了执行 jumbo 的时候自动检测并更新 jumbo 的机制。

### 任意目录安装
新版本的 jumbo 不再要求自己处在 PATH，也不要求一定有 JUMBO_ROOT 环境变量

### 多 repo 支持
新版本的 jumbo 支持配置多个不同的 repo，因此可以支持多个团队分别维护各自的repo

## Jumbo 原则
* Jumbo 只允许管理 JUMBO_ROOT 内部的东西，不能依赖或修改 JUMBO_ROOT 以外的东西（包括但不限于 crontab 等）
* 在不和其他强规范冲突的情况下，尽可能遵循 [Filesystem Hierarchy Standard](http://refspecs.linuxfoundation.org/FHS_2.3/fhs-2.3.html)
* Jumbo 的目的是为了帮助用户解决工作上的问题，通过 jumbo 安装的包不该妨碍工作的话
* Jumbo 的包尽可能使用系统自带的工具和库
* Jumbo 覆盖范围主要是一般终端用户，平台类的软件，或者需要 root 才可以运行的软件，不该包含在 jumbo 中
* Jumbo 不提供单个包多版本共存的功能
